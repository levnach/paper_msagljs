\documentclass{gd-llncs}
%\documentclass[preprint,3p,12pt]{elsarticle}

\usepackage{graphicx}
\usepackage[]{subfig}
\usepackage{svg}
\usepackage[]{pdfpages}
\usepackage[]{svg}

\graphicspath{{./images/}}
% \journal{Computational Geometry: Theory and Applications}

%\newtheorem{theorem}{Theorem}
%\newtheorem{problem}{Problem}
%\newtheorem{lemma}{Lemma}
%\newtheorem{proposition}{Proposition}
%\newenvironment{proof}{\noindent \emph{Proof}: }{\qed}

\newcommand{\comm}[1]{}
\newcommand{\TODO}[1]{{\color{magenta}{#1}}}
\newcommand{\new}[1]{\textcolor{green}{#1}}
%\newcommand{\note}[1]{\textcolor{blue}{[#1]}}

\newcommand{\df}[1]{\mbox{\textbf{#1}}}
\def\Cost{\text{\emph{routing cost}}}
\def\aCost{\text{\emph{additional cost}}}
\newcommand{\gv}{\widetilde{G}}
\newcommand{\ink}{I}
\newcommand{\cc}{C}
\newcommand{\inkcoeff}{k_{\textit{ink}}}
\newcommand{\lencoeff}{k_{\textit{len}}}
\newcommand{\capcoeff}{k_{\textit{cap}}}
\DeclareMathOperator{\nul}{\textit{null}}
\newcommand{\cdt}{$\mathcal{T}$}
\newcommand{\unpath}{$\mathcal{L}$}
\newcommand{\triset}{$\mathcal{U}$}
\newcommand{\plg}{$\mathcal{P}$}
\newcommand{\obst}{$\mathcal{O}$}
\newcommand{\capac}{$\mathcal{C}$}
\begin{document}


\title{Browsing large graphs with MSAGLJS, a graph draph drawing tool in JavaScript }
\author{%
  Lev Nachmanson  \and
  Xiaoji Chen
}%
\institute{
  Microsoft Research, US,\\
  \email{levnach@hotmail.com, cxiaoji@gmail.com},\\
  Msagljs github home page:
  \texttt{https://github.com/microsoft/msagljs}
}
\maketitle

\begin{abstract}
  There has been progress in visualization of large graphs recently. However, interacting with a large graph in an Internet browser with the same ease as browsing an online map, inspecting the high level structure and zooming in to the high level detail, is still an unsolved problem. In this paper we describe novel approaches to several aspects of this problem.

  We give a new algorithm for edge routing, where the edges do not overlap the nodes. The algorithm  produces edge paths which are visually appealing and optimal in their homothopy class.

  To facilitate graph vizualization with DeckGL, we propose a new simple and fast tiling method. The method guarantees that in every view, except of the highest layer, the number of visible entities is not larger than a predefined bound.

  Our method provides a high level overview of the graph.

  The edge routing algorithm mentioned above is reused at the tiling stage to simplify the paths on the lower levels. In addition, we bundle edges per-tile as an optimization heuristic.
\end{abstract}


\section*{Introduction}

\label{sec:intro}

We discuss large but not huge graphs. The maximum number of vertices of graphs we looked at was 28283, and the maximum number of edges was 237010. There are many algorithms that calculate a node layout for such graphs in a few seconds~\cite{hu2015visualizing,brandes2007eigensolver}, and we do not discuss them.

In the first part of the paper we address edge routing where an edge only intersects the nodes it is adjacent to. Our approach works for any node layout, as long as the nodes do not overlap each other. The approach builds on~\cite{dwyer2010fast} and improves it.

\section*{Related work}
\cite{graphviz}

\cite{regraph}

\cite{skewed}

\cite{circos}

\cite{gibson2013survey}

machine learing approach
\cite{kwon2017would}

\cite{lin2013interactive}

\cite{cosmograph}

\section*{Edge routing}
The edge routing starts, as in~\cite{dwyer2010fast}, by building a spanner graph, an approximation of the full visibility graph. The spanner, see Fig.~\ref{fig:spanner}, is built on a variation of a Yao graph, which was introduced independently by Flinchbaugh and Jones~\cite{flinchbaugh1981strong}  and Yao~\cite{yao1982constructing}. This kind of graph is defined by the set of cones with the apices at the vertices. The cones have the same angle, usually in the form of $\frac{2\pi} {n}$, where $n$ is a natural number, and.  The family of cones with the apex at a specific vertex partition the plane as illistrated in Fig.~\ref{fig:yao}. For each cone at most one edge is created connecting the cone apex with a vertex inside of the cone, so the graph has $O(n)$ edges where $n$ is the number of vertices. \\
\begin{figure}[]
  \centering
  \begin{minipage}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{yao.pdf}
    \caption{\small{Yao graph}}
    \label{fig:yao}
  \end{minipage}
  \vfill
  \begin{minipage}[b]{\textwidth}
    \includesvg[width=\textwidth]{visibility_graph.svg}
    \caption{\small{Spanner graph is built using the idea of Yao graphs. The dashed curves are the original node boundaries. Each original curve is surrounded by a polygon with some offset to allow the polyline paths smoothing without intersecting the former. \\
        The edge marked by the circles is created because the top vertex is inside of the cone and it is the closest among such vertices to the cone apex. The apex of the cone is the lower vertex of the edge. \\MSAGLJS uses cone angle $\frac{\pi}{6}$, so the edges of the spanner can deviate from the optimal direction by this angle. Therefore, the shortest paths on the spanner have length that is at most the optimal shortest length multiplied by $\frac{1}{\cos(\frac{\pi}{6})} \simeq 1.155$.}
    }
    \label{fig:spanner}
  \end{minipage}
\end{figure}

The approach of~\cite{dwyer2010fast} first builds a polyline path through the spanner, then applies some local modifications to shorten and smoothen the path. It tries to shortcut a vertex iteratively, as illustrated in Fig~\ref{fig:shortcut}. To smoothen it fits Bezier segments into the polyline corners, using the binary search to find the larger fitting segments,see Fig~\ref{fig:cornerfit}. While anylyzing performance of edge routing in MSAGLJS, we noticed that for a graph with more than 100O nodes these heuristics sometimes create a performance bottleneck in spite of using R-Trees\cite{guttman1984r}.
\begin{figure}[!tbp]
  \centering
  \begin{minipage}[b]{0.4\textwidth}
    \includegraphics[width=\textwidth]{./naive_shorcut_now_working.png}
    \caption{Unsuccessful shortcut}
    \label{fig:shortcut}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.4\textwidth}
    \includegraphics[width=\textwidth]{fillet_corner.png}
    \caption{Fitting a Bezier segment into a polyline corner}
    \label{fig:cornerfit}
  \end{minipage}
\end{figure}
\\
In addition, when the naive shortcutting of polyline corners fails,  the resulting path is not visually appealing, as shown in Fig.~\ref{fig:shortcut}.

We replace these heuristics with a more precize optimization.
\subsection*{Path optimization} {
Remember that a simple polygon is a polygon without holes.

An application of the 'path in a simple polygon' optimization is not a new approach. The authors of~\cite{dobkin1997implementing} used it, but only for hierarchical layouts, where a simple polygon, \plg, containing the path is available. They write: "If \plg~does not contain holes ... we can apply a standard “funnel” algorithm \cite{chazelle1982theorem,hershberger1994computing} for finding Euclidean shortest paths in a simple polygon". In general case, for a non-layered layout, they build the visibility graph which is very expensive.

Here we drop the requirement that $P$ is simple. Indeed, to run the “funnel” algorithm one only needs a sleeve: a sequence of triangles adjoined on an edge and leading from the start to the end of the path.  We show how to build polygon \plg, create a sleeve, and produce an optimized path, for any layout.
Let us describe our method.

We call obstacles $\mathcal{O}$~the set of polygons covering the original nodes, see Fig.~\ref{fig:spanner}. Before routing edges we calculate a Constrained Delaunay Triangulation~\cite{delaunay1934sphere} on $\mathcal{O}$ and call it $\mathcal{T}$. Then for each edge of the graph we proceed with the following steps.

We route a path, called \unpath, on the spanner, as illistrated by Fig.~\ref{fig:non_opt_path_L}.
\begin{figure}[!tbp]
  \centering
  \begin{minipage}[b]{0.45\textwidth}
    \includesvg[width=\textwidth]{non_optimized_path_on_global_cdt.svg}
    \caption{Path \unpath~with \cdt, a fragment.}
    \label{fig:non_opt_path_L}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\textwidth}
    \includesvg[width=\textwidth]{poly2.svg}
    \caption{Polygon \plg~containing \unpath.}
    \label{fig:polygon_with_path}
  \end{minipage}
  \vfill
  \begin{minipage}[b]{0.45\textwidth}
    \includesvg[width=\textwidth]{poly3.svg}
    \caption{New triangulation of \plg.}
    \label{fig:new_triangulation}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.45\textwidth}
    \includesvg[width=\textwidth]{poly4.svg}
    \caption{The optimized path together with the sleeve diagonals.}
    \label{fig:optimized_path}
  \end{minipage}
\end{figure}
Let $\mathcal{S}$ and $\mathcal{E}$ be the obstacles containing correspondengly \unpath's start and end point.
To obtain \plg, let us consider \triset, the set of all triangles ${t} \in \mathcal{T}$ such that
either ${t} \subset \mathcal{S} \cup \mathcal{E}$, or $t$ intersects \unpath~and is not inside of any obstacle in $O \setminus \{S,E\}$  .
The union of \triset~gives us \plg. The boundary of \plg~comprizes all edges $e$ of the triangles from \triset~ such that $e$ is adjacent to exactly one triangle from \triset, see Fig.~\ref{fig:polygon_with_path}. \\
To create the sleeve~\cite{chazelle1982theorem,hershberger1994computing}, we need to have a triangulation of \plg~such that every edge of the triangulation is either a boundary edge of \plg~, or a diagonal of \plg. In our setup \triset~might not have this property, as in Fig.~\ref{fig:polygon_with_path}. We create a new Constrained Delaunay Triangulation of \plg, where the set of constrained edges is the boundary of \plg, see Fig.~\ref{fig:new_triangulation}.\\
We trace \unpath~through the new triangulation and obtain the sleeve. Finally, we apply the funnel algorithm on the sleeve and obtain the path which is the shortest in the homotopy class of \unpath, as illustrated in Fig.~\ref{fig:optimized_path}.\\
The discussion~\cite{pathOpt} of the algorithm helped us in the implementation.\\
\begin{figure}[]
  \centering
  \includegraphics*[width=0.6\textwidth]{sleeve_diagonals_not_optimal.pdf}
  \caption{\plg~is not simple. The dotted path is shorter than the dashed one that was found by the routing.}
  \label{fig:non_optimal_path}
\end{figure}
Polygon \plg~is not neccesserely simple, as shown in Fig.~\ref{fig:non_optimal_path}.
In this example the path that we calculate with the funnel algorithm is not the shortest path inside of \plg.
\subsection*{Performance and quality comparison}
In Fig.~\ref{fig:improved_routing} we compare the paths generated by the old and the new method. We can see that the paths produced by the new method have no kinks. We also know that these paths are  the shorterst in their 'channels'. Arguably, the new method produces better paths.
\begin{figure}[]
  \centering
  \includegraphics*[width=1\textwidth]{comparison.png}
  \caption{The difference in the paths between the old, on the left, and the new, on the right, paths. The arrows on the left fragment point to the kinks that were removed by the new method.}
  \label{fig:improved_routing}
\end{figure}


Our performance experiments are summarized in Table.~\ref{tab:perf}. We see that the older approach outperforms the new one on the smaller graphs; those with the number of nodes under 2000. The new method is faster on the rest of the graphs. We still prefer to use the new method independently of the graph size since the total slowdown is insignificant, under a half second in our experiments, but the quality of the paths is better. On the larger graphs the new method runs faster and produces better paths, so it is an obvious choice.
\begin{table}
  \begin{center}
    \begin{tabular}{||c |c| c| c| c||}
      \hline
      graph                                   & nodes & edges  & old method's time & new time \\ [0.5ex]
      \hline\hline
      social network~\cite{beveridge2018game} & 407   & 2639   & 1.0               & 1.4      \\
      \hline
      b103~\cite{b103}                        & 944   & 2438   & 1.6               & 2.0      \\
      \hline
      b100~\cite{b100}                        & 1463  & 5806   & 5.6               & 5.785    \\
      \hline
      composers~\cite{composers}              & 3405  & 13832  & 510.5             & 17.5     \\
      \hline
      p2p-Gnutella04~\cite{gnutella}          & 10876 & 39994  & 375.4             & 293.8    \\
      \hline
      facebook\_combined~\cite{fb}            & 4039  & 88234  & 132.2             & 119.1    \\
      \hline
      lastfm\_asia\_edges~\cite{feather}      & 7626  & 27807  & 43.3              & 41.4     \\
      \hline
      deezer\_europe\_edges~\cite{feather}    & 28283 & 92753  & 1596.9            & 1209.3   \\
      \hline
      ca-HepPh~\cite{leskovec2007graph}       & 12008 & 237010 & 521.2             & 495.0    \\
      \hline
    \end{tabular}
    \caption{Performance comparison with time in seconds.}
    \label{tab:perf}
  \end{center}

\end{table}
\section{Tiling}
The algorithm works in two phases. The first phase builds more and more detailed levels with smaller tiles until no more tile subdivision is required. Then second phase goes from the higher to lower levels and finalizes the levels.


A tile is a pair of a rectangle and data $(\textit{rect, tile\_data})$. Keys to the tile hierarchy are in the form $(i,j,z)$, where $z$ is the level index and pair $(i,j)$ indicates the rectangle inside of the level. The initial, the tile with the largest rectangle on level $0$ is represented by the triplet $(0,0,0)$. For $z = 1$ there are four tiles $(0,0,1),(0,1,1),(1,0,1)$ and $(1,1,1)$. Each tile $(i,j,z)$ can be subdivided into four tiles of the same size one level higher: $(2i,2j,z+1),(2i,2j+1,z+1), (2i+1,2j,z+1)$, and $(2i+1,2j+1,z+1)$.

Each $z$-level is represented by a map $L(z)$, so $L(z)(i, j)$ gives us a specific tile. During the first phase we can discover some empty tiles which correspond to $L(z)(i, j)$ being not defined.

The tiling works when the edge routing is done, so each edge $e$ has an associated curve $c(e)$. During the subdivision process we create pairs \textit{curve clips}, $(e, p)$, where $p$ is $c(e)$ or a continuous trimmed piece of $c(e)$. By construction we will have the property that for each curve clip $(e,p)$ the curve $p$ belong to the corresponding tile rectangle and it might touch the boundary of rectangle only at the endpoints of $p$.

One of the parameters controlling the algorithm is the number for tile capacity, \capac~, setting the upper limit on how many elements can be visible in one tile. The elements could be a curve clip, an arrowhead, a node, or a label. In our setting \capac~is set by default to $10000$.

The first phase starts with $L(0) = \{(0,0) \rightarrow \textit{tile data}\}$: the map consisting of only one lowest tile, and the elements of \textit{tile data} are all curve clips $e,c(e)$, all graph nodes, all edge labels, and all edge arrowheads. If the total number of these elements is less than \capac~then the first phase stops; this is the usual case for a small graph.

If it is not the case then the first phase continues working. Let us suppose that the curerrent level is $z$. We denote by $C(i,j)$ the number of elements in $L(z)(i,j)$, in other words, the number elements crossing tile $(i,j,z)$.


For the minimal size of the tile we take $(8\times w,8\times h)$, where $w$ is the average width and $h$ is the average height of the nodes of the graph.
The algorithm starts after the edge routing is done, so each edge has a curve, an optional label, and arrowheads associated with it.  The algorithm keeps a map from tilesInitially, we create one top level tile and



\bibliography{main}
\bibliographystyle{ieeetr}
\end{document}
